function mxGeometry(t,i,o,s){mxRectangle.call(this,t,i,o,s)}mxGeometry.prototype=new mxRectangle,mxGeometry.prototype.constructor=mxGeometry,mxGeometry.prototype.TRANSLATE_CONTROL_POINTS=!0,mxGeometry.prototype.alternateBounds=null,mxGeometry.prototype.sourcePoint=null,mxGeometry.prototype.targetPoint=null,mxGeometry.prototype.points=null,mxGeometry.prototype.offset=null,mxGeometry.prototype.relative=!1,mxGeometry.prototype.swap=function(){if(null!=this.alternateBounds){var t=new mxRectangle(this.x,this.y,this.width,this.height);this.x=this.alternateBounds.x,this.y=this.alternateBounds.y,this.width=this.alternateBounds.width,this.height=this.alternateBounds.height,this.alternateBounds=t}},mxGeometry.prototype.getTerminalPoint=function(t){return t?this.sourcePoint:this.targetPoint},mxGeometry.prototype.setTerminalPoint=function(t,i){return i?this.sourcePoint=t:this.targetPoint=t,t},mxGeometry.prototype.rotate=function(t,i){var o=mxUtils.toRadians(t),s=Math.cos(o),e=Math.sin(o);if(!this.relative){var n=new mxPoint(this.getCenterX(),this.getCenterY()),r=mxUtils.getRotatedPoint(n,s,e,i);this.x=Math.round(r.x-this.width/2),this.y=Math.round(r.y-this.height/2)}if(null!=this.sourcePoint){r=mxUtils.getRotatedPoint(this.sourcePoint,s,e,i);this.sourcePoint.x=Math.round(r.x),this.sourcePoint.y=Math.round(r.y)}if(null!=this.targetPoint){r=mxUtils.getRotatedPoint(this.targetPoint,s,e,i);this.targetPoint.x=Math.round(r.x),this.targetPoint.y=Math.round(r.y)}if(null!=this.points)for(var a=0;a<this.points.length;a++)if(null!=this.points[a]){r=mxUtils.getRotatedPoint(this.points[a],s,e,i);this.points[a].x=Math.round(r.x),this.points[a].y=Math.round(r.y)}},mxGeometry.prototype.translate=function(t,i){if(t=parseFloat(t),i=parseFloat(i),this.relative||(this.x=parseFloat(this.x)+t,this.y=parseFloat(this.y)+i),null!=this.sourcePoint&&(this.sourcePoint.x=parseFloat(this.sourcePoint.x)+t,this.sourcePoint.y=parseFloat(this.sourcePoint.y)+i),null!=this.targetPoint&&(this.targetPoint.x=parseFloat(this.targetPoint.x)+t,this.targetPoint.y=parseFloat(this.targetPoint.y)+i),this.TRANSLATE_CONTROL_POINTS&&null!=this.points)for(var o=0;o<this.points.length;o++)null!=this.points[o]&&(this.points[o].x=parseFloat(this.points[o].x)+t,this.points[o].y=parseFloat(this.points[o].y)+i)},mxGeometry.prototype.scale=function(t,i,o){if(t=parseFloat(t),i=parseFloat(i),null!=this.sourcePoint&&(this.sourcePoint.x=parseFloat(this.sourcePoint.x)*t,this.sourcePoint.y=parseFloat(this.sourcePoint.y)*i),null!=this.targetPoint&&(this.targetPoint.x=parseFloat(this.targetPoint.x)*t,this.targetPoint.y=parseFloat(this.targetPoint.y)*i),null!=this.points)for(var s=0;s<this.points.length;s++)null!=this.points[s]&&(this.points[s].x=parseFloat(this.points[s].x)*t,this.points[s].y=parseFloat(this.points[s].y)*i);this.relative||(this.x=parseFloat(this.x)*t,this.y=parseFloat(this.y)*i,o&&(i=t=Math.min(t,i)),this.width=parseFloat(this.width)*t,this.height=parseFloat(this.height)*i)},mxGeometry.prototype.equals=function(t){return mxRectangle.prototype.equals.apply(this,arguments)&&this.relative==t.relative&&(null==this.sourcePoint&&null==t.sourcePoint||null!=this.sourcePoint&&this.sourcePoint.equals(t.sourcePoint))&&(null==this.targetPoint&&null==t.targetPoint||null!=this.targetPoint&&this.targetPoint.equals(t.targetPoint))&&(null==this.points&&null==t.points||null!=this.points&&mxUtils.equalPoints(this.points,t.points))&&(null==this.alternateBounds&&null==t.alternateBounds||null!=this.alternateBounds&&this.alternateBounds.equals(t.alternateBounds))&&(null==this.offset&&null==t.offset||null!=this.offset&&this.offset.equals(t.offset))};